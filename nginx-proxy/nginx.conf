worker_processes auto;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

# Health-checker URL to get the latest provider list
env CONFIG_HEALTH_CHECKER_URL;
# custom local DNS servers to use for resolving the provider list
env CUSTOM_DNS;
# reload interval in seconds (grabs the latest provider list from CONFIG_HEALTH_CHECKER_URL)
env RELOAD_INTERVAL;

http {
    resolver 1.1.1.1 8.8.8.8 valid=300s ipv6=off;
    resolver_timeout 5s;
    lua_package_path "/usr/local/openresty/nginx/lua/?.lua;/usr/local/openresty/lualib/?.lua;;";

    lua_shared_dict providers 10m;
    client_body_buffer_size 10M;
    client_max_body_size 10M;

    access_log /dev/stdout;

    # Proxy cache configuration for JWT verification
    proxy_cache_path /tmp/nginx_auth_cache levels=1:2 keys_zone=auth_cache:10m max_size=100m inactive=10m use_temp_path=off;

	# Schedule periodic reload of the provider list
    init_worker_by_lua_file lua/init_worker.lua;

    # Upstream for Go Auth Service
    upstream go_auth_service {
        server go-auth-service:8081;
        keepalive 10;
    }

    server {
        listen 8080;

        # Auth endpoints - no authentication required, handled by Go service
        location /auth/ {
            proxy_pass http://go_auth_service;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Internal auth endpoint for JWT token validation via Go service with caching
        location = /_auth_verify {
            internal;
            
            # Proxy to Go auth service
            proxy_pass http://go_auth_service/auth/verify;
            proxy_pass_request_body off;
            proxy_set_header Content-Length "";
            proxy_set_header Authorization $http_authorization;
            
            # Cache configuration
            proxy_cache auth_cache;
            # Use JWT token as cache key (extract from Authorization header)
            proxy_cache_key "$http_authorization";
            # Cache only successful responses (200)
            proxy_cache_valid 200 5m;
            # Don't cache errors
            proxy_cache_valid 401 403 429 0;
            # Add cache status to response headers for debugging
            add_header X-Cache-Status $upstream_cache_status always;
            # Cache lock to prevent thundering herd
            proxy_cache_lock on;
            proxy_cache_lock_timeout 1s;
        }

        # Health check endpoint
        location /stub_status {
            stub_status;
        }

        # Main RPC endpoints with hybrid authentication
        location / {
            lua_need_request_body on;
            
            # Hybrid authentication: satisfy either basic auth OR JWT token
            satisfy any;
            
            # 1) Basic Auth via .htpasswd
            auth_basic           "Restricted";
            auth_basic_user_file /etc/nginx/.htpasswd;
            
            # 2) Auth Request for JWT token via Go service (with cache)
            auth_request         /_auth_verify;
            
            # Serve the request using the provider list
            content_by_lua_file lua/request_handler.lua;
        }
    }
}
